pipeline {
    agent any

    environment {
        DOCKER_IMAGE = 'ps-api'
        DOCKER_TAG = "${BUILD_NUMBER}"
        DOCKER_CONTAINER = 'ps-api'
        DOCKER_OLD = "old-ps-api"

        DB_TYPE = 'postgres'
        DB_HOST = credentials('DB_HOST_ID')
        DB_PORT = credentials('DB_PORT_ID')
        DB_USER = credentials('POSTGRES_USER_ID')
        DB_NAME = credentials('POSTGRES_PASSWORD_ID')
        DB_NAME = 'ps'

        JWT_SECRET = credentials('JWT_SECRET_ID')
        JWT_EXPIRES_IN = '1h'
        JWT_REFRESH_SECRET = credentials('JWT_REFRESH_SECRET_ID')
        JWT_REFRESH_EXPIRES_IN = '1h'
        CORS_ORIGIN = 'http://localhost:5173,https://ps-api.itdcmada.com,https://ps.itdcmada.com'
        DEBUG = 'false'
        UPLOAD_MAX_SIZE_MB = '100'
        UPLOAD_DIR = 'uploads'
        TYPEORM_LOGGING = 'true'
        RATE_TTL = '60'
        RATE_LIMIT = '30'
        DB_LOGGING = 'false'
        BACKEND_PROTOCOL = 'https'
        FRONTEND_ORIGIN = 'http://localhost:5173,https://ps-api.itdcmada.com,https://ps.itdcmada.com'

        PORT = '3152'
    }

    stages {

        stage('Build Docker Image') {
            steps {
                sh """
                docker build --build-arg DB_TYPE=${DB_TYPE} \
                --build-arg DB_HOST=${DB_HOST} \
                --build-arg DB_PORT=${DB_PORT} \
                --build-arg DB_USER=${DB_USER} \
                --build-arg DB_PASS=${DB_PASS} \
                --build-arg DB_NAME=${DB_NAME} \
                --build-arg JWT_SECRET=${JWT_SECRET} \
                --build-arg JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET} \
                --build-arg JWT_EXPIRES_IN=${JWT_EXPIRES_IN} \
                --build-arg CORS_ORIGIN=${CORS_ORIGIN} \
                --build-arg DEBUG=${DEBUG} \
                --build-arg UPLOAD_MAX_SIZE_MB=${UPLOAD_MAX_SIZE_MB} \
                --build-arg UPLOAD_DIR=${UPLOAD_DIR} \
                --build-arg TYPEORM_LOGGING=${TYPEORM_LOGGING} \
                --build-arg RATE_TTL=${RATE_TTL} \
                --build-arg RATE_LIMIT=${RATE_LIMIT} \
                --build-arg DB_LOGGING=${DB_LOGGING} \
                --build-arg BACKEND_PROTOCOL=${BACKEND_PROTOCOL} \
                --build-arg FRONTEND_ORIGIN=${FRONTEND_ORIGIN} \
                --build-arg PORT=${PORT} \
                -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
                """
            }
        }

        stage('Deploy with Rollback') {
            steps {
                script {

                    // 1. Sauvegarder l'ancien conteneur
                    sh """
                    if docker ps -a --format '{{.Names}}' | grep -w ${DOCKER_CONTAINER}; then
                        echo "Saving current container as backup..."
                        docker rename ${DOCKER_CONTAINER} ${DOCKER_OLD}
                    fi
                    """

                    // 2. Lancer le nouveau conteneur
                    sh """
                    docker run -d --name ${DOCKER_CONTAINER} -p ${PORT}:${PORT} ${DOCKER_IMAGE}:${DOCKER_TAG}
                    """

                    // 3. Vérifier qu'il fonctionne (test health-check API)
                    def status = sh (
                        script: "sleep 5 && curl -s -o /dev/null -w '%{http_code}' http://localhost:${PORT}/",
                        returnStdout: true
                    ).trim()

                    if (status != "200") {
                        error("❌ Nouveau conteneur invalide, rollback en cours...")
                    }

                    // 4. Supprimer ancien si tout est OK
                    sh """
                    if docker ps -a --format '{{.Names}}' | grep -w ${DOCKER_OLD}; then
                        docker rm -f ${DOCKER_OLD}
                    fi
                    """

                }
            }
            post {
                failure {
                    script {
                        // 5. Rollback automatique
                        sh """
                        echo "Rollback: restauration de l'ancien conteneur..."
                        docker rm -f ${DOCKER_CONTAINER} || true
                        if docker ps -a --format '{{.Names}}' | grep -w ${DOCKER_OLD}; then
                            docker rename ${DOCKER_OLD} ${DOCKER_CONTAINER}
                            docker start ${DOCKER_CONTAINER}
                        fi
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            sh "docker rmi ${DOCKER_IMAGE}:${DOCKER_TAG} || true"
        }
    }
}
